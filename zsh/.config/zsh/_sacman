#compdef sacman

_sacman() {
    # 1. Ensure _systemctl is available and sourced.
    if ! (( $+functions[_systemctl] )); then
        emulate -L zsh
        local compfile="${(v)fpath[(r)_systemctl]}"
        if [[ -f "$compfile" ]]; then
            source "$compfile"
        else
            _message 'could not load _systemctl completion script'
            return 1
        fi
    fi

    # 2. Parse the sacman command line BEFORE the cursor position.
    local user_flag=""
    local sacman_op_arg=""
    local -a unit_args
    
    # Pass 1: Find the user flag and the main operation argument.
    integer i
    for (( i=2; i<CURRENT; i++ )); do
        local word="${words[$i]}"
        case "$word" in
            # Check for --user flag explicitly or within a combined argument.
            -*u*|--user)
                user_flag="--user"
                ;;
        esac

        case "$word" in
            # An operation must start with one of these letters.
            # We assume the FIRST such argument is the operation.
            -[SRQFT]*)
                if [[ -z "$sacman_op_arg" ]]; then
                    sacman_op_arg="$word"
                else
                    # A second op-like arg is treated as a unit, e.g., for `sacman -S -a.service`
                    unit_args+=("$word")
                fi
                ;;
            # Anything that's not a recognized global flag or the op is a unit.
            -u|--user)
                ;; # ignore, already handled
            *)
                unit_args+=("$word")
                ;;
        esac
    done
    
    # 3. Translate the sacman operation into a systemctl command.
    local systemctl_cmd="status" # Default command if no operation is given.
    if [[ -n "$sacman_op_arg" ]]; then
        # Remove the leading dash and any global flags from the operation string.
        local opts="${sacman_op_arg##-}" 
        opts=${opts//u/} # Purify the opts string by removing 'u'
        
        if [[ "$opts" == *S* ]]; then
            if   [[ "$opts" == *d* ]]; then systemctl_cmd="reload"
            elif [[ "$opts" == *t* && "$opts" == *y* ]]; then systemctl_cmd="restart"
            elif [[ "$opts" == *t* ]]; then systemctl_cmd="start"
            elif [[ "$opts" == *y* ]]; then systemctl_cmd="reenable"
            else systemctl_cmd="enable"; fi
        elif [[ "$opts" == *R* ]]; then
            if   [[ "$opts" == *t* ]]; then systemctl_cmd="stop"
            elif [[ "$opts" == *m* ]]; then systemctl_cmd="mask"
            else systemctl_cmd="disable"; fi
        elif [[ "$opts" == *Q* ]]; then
            if   [[ "$opts" == *l* ]]; then systemctl_cmd="list-unit-files"
            elif [[ "$opts" == *i* ]]; then systemctl_cmd="status"
            elif [[ "$opts" == *d* ]]; then systemctl_cmd="cat"
            # Note: sacman -Qu is "show", which takes a unit.
            # This was a bug in previous versions' logic.
            elif [[ "$opts" == *u* ]]; then systemctl_cmd="show" 
            else systemctl_cmd="status"; fi
        elif [[ "$opts" == *F* && "$opts" == *e* ]]; then
            systemctl_cmd="edit"
        elif [[ "$opts" == *T* ]]; then
            if   [[ "$opts" == *e* ]]; then systemctl_cmd="is-failed"
            elif [[ "$opts" == *s* ]]; then systemctl_cmd="is-enabled"
            else systemctl_cmd="is-active"; fi
        fi
    fi

    # 4. Construct the fake context for _systemctl.
    local -a faked_words
    faked_words=("systemctl")
    if [[ -n "$user_flag" ]]; then
        faked_words+=("$user_flag")
    fi
    faked_words+=("$systemctl_cmd")
    faked_words+=("${unit_args[@]}")

    # 5. Delegate to _systemctl within a localized scope.
    local -a words
    words=("${faked_words[@]}" "${words[CURRENT]}")
    
    local CURRENT=${#words[@]}
    
    _systemctl
    
    return $?
}

